package utils

import (
	"fmt"
	"crypto/rand"
	"io"
	"bytes"
	"crypto/ecdsa"
	"crypto/sha256"
	"crypto/x509"
	"encoding/pem"
	"errors"
	"math/big"
	"github.com/hyperledger/fabric/core/chaincode/shim"
)

func Delete(stub shim.ChaincodeStubInterface, key string) ([]byte, error) {
	buf, err := stub.GetState(key)
	if err != nil {
		return nil, err
	}
	err = stub.DelState(key)
	return buf, err
}

var b58Alphabet = []byte("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")

func GetAddress(stub shim.ChaincodeStubInterface) ([]byte, error) {
	creatorByte, err := stub.GetCreator()
	if err != nil {
		return nil, err
	}

	certStart := bytes.Index(creatorByte, []byte("-----BEGIN"))
	if certStart == -1 {
		return nil, errors.New("No creator certificate found")
	}
	certText := creatorByte[certStart:]

	bl, _ := pem.Decode(certText)
	if bl == nil {
		return nil, errors.New("Could not decode the PEM structure")
	}

	cert, err := x509.ParseCertificate(bl.Bytes)
	if err != nil {
		return nil, errors.New("Parse Certificate failed")
	}

	if pub, ok := cert.PublicKey.(*ecdsa.PublicKey); ok {
		pubKey := append(pub.X.Bytes(), pub.Y.Bytes()...)
		publicSHA256 := sha256.Sum256(pubKey)
		address := Base58Encode(publicSHA256[:])

		return address, nil
	}

	return nil, errors.New("Only support ECDSA")
}

// Base58Encode encodes a byte array to Base58
func Base58Encode(input []byte) []byte {
	var result []byte

	x := big.NewInt(0).SetBytes(input)

	base := big.NewInt(int64(len(b58Alphabet)))
	zero := big.NewInt(0)
	mod := &big.Int{}

	for x.Cmp(zero) != 0 {
		x.DivMod(x, base, mod)
		result = append(result, b58Alphabet[mod.Int64()])
	}

	ReverseBytes(result)

	return result
}

// Base58Decode decodes Base58-encoded data
func Base58Decode(input []byte) []byte {
	result := big.NewInt(0)

	for _, b := range input {
		charIndex := bytes.IndexByte(b58Alphabet, b)
		result.Mul(result, big.NewInt(58))
		result.Add(result, big.NewInt(int64(charIndex)))
	}

	decoded := result.Bytes()

	return decoded
}

// ReverseBytes reverses a byte array
func ReverseBytes(data []byte) {
	for i, j := 0, len(data)-1; i < j; i, j = i+1, j-1 {
		data[i], data[j] = data[j], data[i]
	}
}

// GenerateBytesUUID returns a UUID based on RFC 4122 returning the generated bytes
func GenerateBytesUUID() []byte {
	uuid := make([]byte, 16)
	_, err := io.ReadFull(rand.Reader, uuid)
	if err != nil {
		panic(fmt.Sprintf("Error generating UUID: %s", err))
	}

	// variant bits; see section 4.1.1
	uuid[8] = uuid[8]&^0xc0 | 0x80

	// version 4 (pseudo-random); see section 4.1.3
	uuid[6] = uuid[6]&^0xf0 | 0x40

	return uuid
}

func Sha256Encode(date []byte) []byte {
	d := sha256.Sum256(date)
	return Base58Encode(d[:])
}

func AppendString(tag *[]string, src string) {
	if src != "" {
		*tag = append(*tag, src)
	}
}
